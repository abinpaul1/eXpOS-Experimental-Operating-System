alias currentPID R0;
currentPID = [SYSTEM_STATUS_TABLE+1];

// Storing BP into kernel stack

SP = SP+1;
[SP] = BP;

alias process_table_entry R1;
process_table_entry = PROCESS_TABLE + currentPID*16;

[process_table_entry + 12] = SP%512;
[process_table_entry + 14] = PTBR;
[process_table_entry + 15] = PTLR;


alias newPID R2;
alias pte R3;
alias temp_state R4;
alias temp_pid R5;


// Default new process is set as idle
newPID = 0;

alias iter R6;
temp_pid = currentPID;

//If Paging is ongoing
if ([SYSTEM_STATUS_TABLE + 5]!=0) then
  //If process is not blocked
  if ( [process_table_entry + 4]==READY || [process_table_entry + 4]==RUNNING) then
    //Schedule swapper daemon
    newPID = 15;
  endif;
else
  iter = 1;
  // Loops till end of process table
  while (iter<=15) do
      if (temp_pid<15) then
        temp_pid = temp_pid + 1;
      else
        temp_pid = 1;
      endif;

      //Excluding swapper daemon
      if (temp_pid == 15) then
        iter = iter + 1;
        continue;
      endif;
      
      pte = PROCESS_TABLE + temp_pid*16;
      temp_state = [pte + 4];
      if ( (temp_state == CREATED || temp_state == READY) && [pte+6]==0 ) then
            newPID = temp_pid;
            break;
      endif;
      iter = iter + 1;
  endwhile;
endif;


alias new_process_table R7;
new_process_table = PROCESS_TABLE + newPID*16;

SP = [new_process_table + 11]*512 + [new_process_table + 12];
PTBR = [new_process_table + 14];
PTLR = [new_process_table + 15];

[SYSTEM_STATUS_TABLE+1] = newPID;

if ([new_process_table + 4] == CREATED) then
    SP = [new_process_table + 13];
    //Setting BP to the value stored at the beginning of the kernel stack
    BP = [[new_process_table + 11]*512 + [new_process_table + 12]];
    [new_process_table + 4] = RUNNING;
    // Mode flag to 0
    [new_process_table + 9] = 0;
    //scheduler directly starts execution in user mode
    ireturn;
endif;

[new_process_table + 4] = RUNNING;

//Restoring BP from kernel stack
BP = [SP];
SP = SP - 1;

return;
